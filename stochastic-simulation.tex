\section{Stochastic Simulation}
In this section we compare Bitcoin's and PoEM's latency experimentally.
We simulate various executions of Bitcoin and PoEM with different parameterizations.
In each simulation, we fix the block production rate $g$ and adversarial ratio $\beta$, and we
measure the latency of the system.
The latency of the system is the time it takes for a block to become confirmed.
Namely, we measure the time needed from the moment an honest block is mined until
the first time any honest party considers the block stable, and only for those blocks
which eventually do become stable.
We use the private mining attack as the adversarial strategy, which was
proven~\cite{eiar} to be the best possible attack against Bitcoin in the continuous-time model~\cite{bitcoin-made-simple}.
In a nutshell, in this strategy, the adversary mines blocks in private on her own chain, whereas the honest parties mine
their own blocktree, following the heaviest chain rule (in Bitcoin) or the most intrinsic work rule (in PoEM) respectively.
The adversary imposes a network delay of $\Delta$ to honest parties.
% TODO: Cite proof that the adversary's strategy is optimal, wrt to largest possible Δ. (cite EiaR)
% TODO: Our analysis is in the discrete-time model, but the simulations are in the continuous-time model.

To save time, instead of wastefully simulating proof of work, we artificially simulate block production by a stochastic process
as follows.
We first simulate the execution of honest parties. We observe that the time between the creation of two blocks is
exponentially distributed~\cite{bitcoin-made-simple} with rate $g$.
Hence, we take multiple independent samples from $\exp(g)$ to get the interval between each successive honest block production event,
thereby giving rise to a Poisson process of block creations. In the static Bitcoin model, the work of each block is equal to one,
whereas the work of a PoEM block is exponentially
distributed with rate $\frac{1}{\ln2}$ (and note that these exponential samples of work are a different, parallel process
from the exponential samples of time intervals). Hence, in PoEM's case, we sample from $\exp(\frac{1}{\ln2})$ to get the work
of each block in the execution. The creation time of each block and its work are enough to simulate the honest parties' execution
and determine the blocktree that was constructed.
% TODO: How do you determine the height of the blocktree?

Then, independently we simulate the adversary's execution. Like in the honest execution, we sample from $\exp(g\frac{\beta}{1 - \beta})$
to get the interval between the time of successive adversarially produced blocks, where $g\frac{\beta}{1 - \beta}$ is the adversary's block production rate.
Then, we set the work of each block to $1$ for the case of static Bitcoin, and sample from $\exp(\frac{1}{\ln2})$ to get the work of each block in the execution for the case of PoEM.
Since the adversary has no network delay, all her blocks are chained in series.
% TODO: What about the adversary in Bitcoin?
% TODO: Talk about the initial sampling of the adversarial execution and the scaling with $\beta$ retroactively

Having simulated the honest and adversary executions, we can determine the latency of the system.
To do this, we determine the last point in time when the adversary had a chain with more work than the honest parties,
and we record the work $k$ of the honest chain that surpasses the adversary's chain immediately after that time.
For this execution, a confirmation parameter larger or equal to $k$ would safeguard the protocol from a Common Prefix violation.
% TODO: Footnote that this k is safe only against the EiaR attack, and not other possible attacks, even though EiaR is the
% best possible attack wrt resilience.

To accurately calculate the latency of a given system parameterization $(g, \beta)$, we simulate multiple such executions and record the minimum confirmation
% TODO: What is your Monte Carlo iteration count?
parameter $k$ for each. We set $k^*$ to be the minimum confirmation parameter that would safeguard $90\%$ of the executions against a Common Prefix violation.
% TODO: Can you explain how k^* is calculated precisely?
The latency of the system is now calculated as $\frac{k^*}{d}$, were $d$ is the average time it takes to produce $k^*$ work in the executions
(both in Bitcoin and PoEM).
% TODO: Explicitly write out what d is in case of Bitcoin and PoEM.

To get the optimal system latency given an adversarial ratio $\beta$, we explore the latency of the system for various block production rates $g$.
The $g$ that minimizes the latency of the system is the optimal block production rate for a given adversarial ratio $\beta$.

% TODO: Figures?
% TODO: What about γ?
% TODO: Interpret the plots and tell us a narrative about the results.