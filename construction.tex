\section{Construction}
In the \poem construction, only the fork choice rule
of the original Bitcoin protocol is modified.
Honest parties, instead of adopting the longest chain, at the beginning
of each round, now adopt the chain with the most intrinsic work.

A block is any triplet of the
form $B = (h, x, \ctr)$, where $h \in \{0,1\}^\kappa$, $x \in \{0, 1\}^*$, and $\ctr \in \N$.
The hash of block $B$ is denoted as $H(B) = H(h \concat x \concat \ctr)$.
The $h$ is a reference to a previous block $B'$ and
contains the first $\kappa$ bits of its hash $H(B')[{:}{\kappa}]$
(recall that, in the real-valued random oracle model, each hash
output has an infinite real-valued bit expansion, but only the first
$\kappa$ bits are included in this reference).

A \emph{chain} $C$ is a sequence of blocks beginning with a designated
block $G$, the \emph{genesis block}. When a chain $C$ appears in the execution,
we say that block $C[j]$ \emph{extends} block $C[i]$ if $i < j$.

\begin{definition}[Block Intrinsic Work]
  The \emph{intrinsic work} of a block hash
  $A$ is denoted as $\work(A) = -\lg A$.
  The \emph{approximate intrinsic work} of a block hash $A$ is denoted
  $\awork(A) = -\lg A[{:}{\kappa}]$.
\end{definition}

In this definition, the full hash value, interpreted as a real number in the interval
$(0, 1)$, is used, whereas approximate work uses only the first $\kappa$ bits of the
value. Said differently, for any $A \in (0, 1)$,
$\awork(A) = -\lg \frac{\lfloor 2^\kappa A \rfloor}{2^\kappa}$.

\begin{definition}[Chain Intrinsic Work]
  The \emph{intrinsic work} of a chain
  $C$ is the sum of the
  intrinsic work of all blocks in $C$.
  It is denoted as $\work(C) = \sum_{B \in C}{\work(H(B))}$.
  The \emph{approximate intrinsic work} of a chain
  is $\awork(C) = \sum_{B \in C}{\awork(H(B))}$.
\end{definition}

\noindent
\myparagraph[Blockchain notation]
For chain $C$, we write $[\alpha] \lhd C$
to denote the $i^\text{th}$ block of $C$ such that
$\work(C[{:}{i - 1}]) < \alpha \leq \work(C[{:}{i}])$.
If $\work(C) < \alpha$, then let $[\alpha] \lhd C = \bot$.
If $\alpha$ is negative, then $[\alpha] \lhd C$ is defined as
the $i^\text{th}$ block of $C$ such that
$\work(C[{i - 1}{:}]) < -\alpha \leq \work(C[{i}{:}])$.
We write $[{\alpha}{:}{\beta}] \lhd C$ to denote
$C[{i}{:}{j}]$ where $i$ is the index of $[\alpha] \lhd C$
and $j$ is the index of $[\beta] \lhd C$ in $C$ respectively.
The notation $[{\alpha}{:}] \lhd C$ means $C[{i}{:}]$,
and the notation $[{:}\beta] \lhd C$ means $C[{:}{j}]$,
where $i$ and $j$ are defined with respect to $\alpha$ and $\beta$
respectively as above.
Given a block $B$, we denote by $B.x$ the sequence of transactions
included in $B$.
Given a chain $C$, we denote by $C.x$
the sequence of transactions in all the blocks of $C$ in order, namely
${\big\lVert}_{B \in C} B.x$.

In Algorithm~\ref{alg.backbone} we show the code of an honest party.
First, the party is constructed using the \constructor function (Line~\ref{alg-backbone.constructor}).
In every round, each party is executed by the environment using function \execute
(note that this function is due to the lockstep round-based nature of
our time model).

At the beginning of each round, the honest party calls $\net.\receive()$ to get all
the chains from the network (Line~\ref{alg-backbone.receive}).
It then adopts the ``best'' valid chain seen so far (including the chain
he already has).
This comparison for the ``best'' chain is performed by
function \maxvalid in Line~\ref{alg-backbone.maxvalid}, and
is the single point that we deviate from the original Bitcoin protocol.
Next, the honest party attempts to mine a block using the \pow function (Line~\ref{alg.pow}),
which also remains the same as the original protocol: He repeatedly tries to find a block $B$
that satisfies the \pow equation $\aH(B) < T$, where the target $T$ is a small real number in
the interval $(0, 1)$ satisfying $T = T[{:}\kappa]$ (this last equality guarantees that $T$ can be stored in
$\kappa$ bits).
If a block is found, this block is broadcast\footnote{We use the term \emph{broadcast}
to mean the unreliable, best-effort anonymous manner of communication between honest parties that
guarantees message delivery from one honest party to all other honest parties.
This is called \emph{diffuse} in the Backbone series of works.}
to the network using function $\net.\broadcast()$.

\import{./}{algorithms/algorithm-honest.tex}
\import{./}{algorithms/algorithm-pow.tex}

We will now analyze the functionality of \maxvalid. The method receives as input
a set of chains and returns the ``best'' chain based on a validation and
chain adoption rule. The function iterates over all the provided chains
and first checks their validity in Line~\ref{alg-maxvalid:validate}, using
function \validate (Algorithm~\ref{alg.validate}). The \validate function remains unchanged compared to
the original Bitcoin protocol.
The chains that satisfy the validation rule
are compared with one another in order to find the chain
with the most intrinsic work. Finally, in Line~\ref{alg-maxvalid:return}, we return the
``best'' chain $C_{\mmax}$.

When the time comes to report the stable chain
(function $\lread$ in Algorithm~\ref{alg.backbone} Line~\ref{alg-backbone.read}),
the honest party removes the unstable part of the chain, namely
the last $k$ bits of work from the chain, and reports
the remaining chain as stable. Note that, contrary to Bitcoin,
the variable $k$ is measured in bits of work, and not in blocks
(looking ahead, $k$ will be shown to be polynomial in the
security parameter $\kappa$, and we will calculate its value
in the analysis section).

This concludes the \poem construction.

\import{./}{algorithms/algorithm-maxvalid.tex}
\import{./}{algorithms/algorithm-validate.tex}



%\import{./}{algorithms/algorithm-operators.tex}
