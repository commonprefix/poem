\section{Definitions}

%TODO: Define python notation [:]. (create notation paragraph)

%TODO: Define intrinsic work

We let $\kappa$ be the security parameter.
We model our hash function $H$ as a random oracle~\cite{ro}.

\begin{definition}[Random Oracle]
  The \emph{random oracle}, when queried with a value $x$ for the first time,
  returns a value $y$, sampled uniformly at random from $\{0, 1\}^\kappa$,
  and stores the pair $(x, y)$. If the oracle
  is queried again with $x$, it returns the same $y$.
\end{definition}

\begin{definition}[Distributed Ledger Protocol]
  A distributed ledger protocol is an Interactive Turing Machine (ITM)
  which exposes the following methods:

  \begin{itemize}
    \item $\lwrite(\tx)$:
          Takes user input by accepting some valid transaction \tx.
    \item $\lread()$:
          Produces user output in the form of a ledger, namely, a
          sequence of transactions.
  \end{itemize}
\end{definition}
%TODO: Define Distributed Ledger protocols, transactions, and notation $\Ledger[P][][r]$, notation ~, notation
%      $\preccurlyeq$.


\begin{definition}[Safety]
  A distributed ledger protocol is \emph{safe} if
  for any two honest parties $P_1, P_2$ and any two rounds $r_1, r_2$, it holds that either
  $\Ledger[P_1][][r_1] \preccurlyeq \Ledger[P_2][][r_2]$ or $\Ledger[P_2][][r_2] \preccurlyeq \Ledger[P_1][][r_1]$.
\end{definition}

\begin{definition}[Liveness]
  A distributed ledger protocol is \emph{live}$(u)$ if
  for any honest party that attempts to inject a transaction $\tx$
  at round $r$, it holds that $\tx \in \Ledger[P][][r+u]$
  for all honest parties $P$.
\end{definition}

\begin{definition}[Secure]
  A distributed ledger protocol is \emph{secure} if it is
  both safe and live$(u)$.
\end{definition}

\textbf{Notation.}

