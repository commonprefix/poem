\section{Definitions \& Model}\label{sec:model}

\noindent
\myparagraph[Notation]
Given a sequence $Y$, we address it using $Y[i]$ to mean the $i^\text{th}$ element (starting from $0$).
We use $|Y|$ to denote the length of $Y$.
Negative indices address elements from the end, so $Y[-i]$ is the $i^\text{th}$ element from
the end, and $Y[-1]$ in particular is the last. We use $Y[i{:}j]$ to denote the subarray of $Y$
consisting of the elements indexed from $i$ (inclusive) to $j$ (exclusive). The notation $Y[i{:}]$ means the
subarray of $Y$ from $i$ onwards, while $Y[{:}j]$ means the subsequence of $Y$ up to (but not including) $j$.
The notation $\concat$ denotes the concatenation of two strings.
Given a sequence of strings $(Y_i)_{i \in [n]}$ we denote by $\big\lVert_{i \in [n]} Y_i$ the concatenation
of all the strings in the sequence, in order. We denote by $\Bern(p)$ the Bernoulli distribution with parameter $p$,
and $\Exp(\lambda)$ the exponential distribution with mean $\frac{1}{\lambda}$.
We use $\rightarrow$ to mean implication, and $\Rightarrow$ to mean a logical
deduction step in a proof.

\begin{definition}[Distributed Ledger Protocol]
  A \emph{distributed ledger protocol} is an Interactive Turing Machine (ITM)
  which exposes the following methods:

  \begin{itemize}
    \item $\lwrite(\tx)$:
      Takes user input by accepting some transaction \tx.
    \item $\lread()$:
      Produces user output in the form of a \emph{ledger} (a sequence of transactions)
  \end{itemize}
\end{definition}

The distributed ledger protocol is executed by a set of $n$ parties.
In a distributed ledger protocol execution, the notation
$\Ledger[P][][r]$ denotes the output of $\lread()$
invoked on party $P$ at the end of round $r$.
We denote that ledger
$\Ledger[P_1][][r_1]$ is a prefix of ledger $\Ledger[P_2][][r_2]$,
using the notation
$\Ledger[P_1][][r_1] \preccurlyeq \Ledger[P_2][][r_2]$. When
$(\Ledger[P_1][][r_1] \preccurlyeq \Ledger[P_2][][r_2]) \lor (\Ledger[P_2][][r_2] \preccurlyeq \Ledger[P_1][][r_1])$ holds,
we use the notation $\Ledger[P_1][][r_1] \sim \Ledger[P_2][][r_2]$.

\begin{definition}[Safety]
  A distributed ledger protocol is \emph{safe} if
  for any honest parties $P_1, P_2$ and any rounds $r_1, r_2$, it holds that
  $\Ledger[P_1][][r_1] \sim \Ledger[P_2][][r_2]$.
\end{definition}

\begin{definition}[Liveness]
  A distributed ledger protocol is \emph{live}$(u)$ if
  for any honest party that attempts to inject a transaction $\tx$
  at round $r$, it holds that $\tx \in \Ledger[P][][r+u]$
  for all honest parties $P$.
\end{definition}

\begin{definition}[Security]
  A distributed ledger protocol is \emph{secure} if it is
  both safe and live$(u)$.
\end{definition}

\noindent
\myparagraph[Bitcoin Backbone]
We analyze the protocol using the model introduced in the Bitcoin Backbone~\cite{backbone} paper.
The protocol execution commences in discrete rounds $1, 2, \ldots$, and has a total duration of
$L$, polynomial in the security parameter $\kappa \in \mathbb{N}$.
We assume a synchronous communication network: If an honest party sends a message
to the network at some round $r$, this message is delivered to all honest parties
(including itself) at round $r + 1$.
We also assume a static setting, where the protocol is executed by
a fixed total number of $n \in \mathbb{N}$ parties, unknown to the honest parties.
In the execution, the adversary controls $t < n$ of the parties,
and each of the $n - t$ other parties are honest and execute the prescribed Distributed Ledger
Protocol. We let the first $1, 2, \ldots, n - t$ parties be the honest parties
and the last $n - t + 1, \ldots, n$ parties be the corrupted parties, which may behave arbitrarily.
This choice is without loss of generality~\cite[Proposition 18]{backbone}.
Parties communicate through an unauthenticated network,
meaning that the adversary can ``spoof''~\cite{douceur2002sybil}
the source address of any message that is delivered.

\noindent
\myparagraph[Static difficulty]
Our analysis is in the \emph{static population} model in which the difficulty
and target remain static. In the static model, Bitcoin uses the \emph{longest chain rule}~\cite{backbone},
where each block counts for $1$ unit.
On the contrary, in the real deployment of Bitcoin, the difficulty is dynamically adjusted (the
\emph{variable population} model~\cite{varbackbone}), and the \emph{heaviest chain} is chosen.
The scoring in the variable difficulty model makes each block count for $\frac{1}{T}$, where
$T$ is the nominal target of the block. In \poem, we count the \emph{intrinsic work}
of each block, which is different from the nominal target $T$ and depends on the value $H(B) < T$,
and choose the heaviest chain based on this rule: Each block counts for $-\lg\frac{H(B)}{T}$.
Like Bitcoin, \poem can also be adapted to work in the variable difficulty setting by adjusting
the difficulty depending on the observed block production rate of the system.
We perform our analysis in the static population model, and leave the analysis in the variable
population model for future work.

We work in the following variant of the Random Oracle model~\cite{ro}, in which
the random oracle returns a \emph{real number} instead of $\kappa$ bits of output.
One technicality with this model is that the real-number cannot directly be returned
to the machine invoking the oracle. Instead, we allow the querying machine to choose which
bit of the number to obtain.

\begin{definition}[Real-Valued Random Oracle]
  The \emph{real-valued random oracle} $H$ can be queried with a value $x$ and a bit index $j$.
  When queried with $x$ for the first time,
  it samples a real value $y$ uniformly at random from the continuous interval $(0, 1)$,
  and returns its $j$-th bit from the binary representation of the real number $y$.
  It then remembers the pair $(x, y)$.
  When queried with $x$ for a subsequent time, it returns the $j$-th bit
  of the stored $y$.
\end{definition}

We denote by $H(x)[{i}{:}{j}]$ the query that obtains the slice of $H(x)$ from bit index $i$ to $j$.
We liberally use the rest of the previously introduced slicing notation with the hash output,
implying that the random oracle is queried with the desired number of bits.
In particular, we will write $\aH(x)$ to denote $H(x)[{:}{\kappa}]$.

\noindent
\textbf{The $q$-bounded model.}
Following the tradition of the Bitcoin Backbone~\cite{backbone} paper,
during each round, each honest party is allowed to query the random oracle with $q$
different $x$ values. Similarly, the adversary is allowed to query the random oracle
with $t q$ different $x$ values.